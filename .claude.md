# Claude Code Guide for vizgres

This document provides guidance for using Claude Code (or AI assistants) when working on vizgres.

## Project Overview

**vizgres** is a fast, keyboard-driven PostgreSQL TUI client written in Rust.

### Key Technologies

- **Language**: Rust 2024 edition, MSRV 1.85
- **TUI**: ratatui + crossterm
- **Database**: tokio-postgres
- **Async**: tokio
- **Testing**: testcontainers, insta (snapshots)

### Architecture

The project follows an Elm-like architecture with:
- Unidirectional data flow
- Event-driven state updates
- Trait-based database abstraction
- Component-based UI

## Current Status

**Status**: Scaffolding complete (Phase 0)

The project has:
- ✅ Full module structure with stubs
- ✅ Core type definitions
- ✅ Trait definitions
- ✅ Error hierarchy
- ✅ Test infrastructure
- ✅ CI/CD pipeline
- ❌ No working implementations yet

All features are marked with `todo!()` or `#[ignore]` test attributes.

## Implementation Roadmap

Development follows 8 phases (see `docs/09-roadmap.md`):

1. **Phase 1**: Foundation - Connection & basic query execution
2. **Phase 2**: Core UI - Panel layout & navigation
3. **Phase 3**: Tree Browser - Schema introspection
4. **Phase 4**: Query Editor - Multi-line editing & formatting
5. **Phase 5**: Results Viewer - Table display & scrolling
6. **Phase 6**: Polish - EXPLAIN, export, commands
7. **Phase 7**: Autocomplete - Context-aware suggestions
8. **Phase 8**: Connections - Full connection management

## Working with Claude Code

### Starting a Task

When beginning work:

1. **Check the current phase** in `docs/09-roadmap.md`
2. **Read relevant documentation** in `docs/`
3. **Look for TODO comments** marked with the phase number
4. **Run tests** to understand what's expected

### Making Changes

Follow these practices:

#### Code Quality

```bash
# Before committing, always run:
cargo fmt
cargo clippy --all-targets -- -D warnings
cargo test
```

#### Adding Features

1. **Find the stub**: Look for `todo!()` or `unimplemented!()`
2. **Read the docs**: Check trait documentation and examples
3. **Write tests first**: Add or uncomment tests
4. **Implement**: Replace stub with working code
5. **Test**: Ensure tests pass

Example workflow:
```rust
// Find stub in src/db/postgres.rs
async fn execute_query(&self, _sql: &str) -> DbResult<QueryResults> {
    todo!("Query execution not yet implemented")  // <- Replace this
}

// Check tests in tests/integration/database_connection.rs
#[tokio::test]
#[ignore = "Phase 1: Requires testcontainers setup"]
async fn test_execute_simple_query() { /* ... */ }

// Implement the function
async fn execute_query(&self, sql: &str) -> DbResult<QueryResults> {
    let rows = self.client.query(sql, &[])
        .await
        .map_err(|e| DbError::QueryFailed(e.to_string()))?;

    // Convert rows to QueryResults...
}

// Remove #[ignore] from test and verify it passes
```

#### Documentation

Update documentation when:
- Adding new public APIs
- Changing behavior
- Implementing phase features

Use doc comments with examples:
```rust
/// Execute a SQL query and return results
///
/// # Examples
/// ```ignore
/// let results = provider.execute_query("SELECT 1").await?;
/// assert_eq!(results.rows.len(), 1);
/// ```
///
/// # Errors
/// Returns `DbError::QueryFailed` if query execution fails
```

### Common Tasks

#### Adding a New Database Operation

1. Add method to `DatabaseProvider` trait in `src/db/provider.rs`
2. Implement in `PostgresProvider` in `src/db/postgres.rs`
3. Add tests in `tests/integration/`
4. Update documentation

#### Adding a UI Component

1. Check `src/ui/<component>.rs` for stub
2. Implement `Component` trait methods
3. Add rendering logic with ratatui
4. Create snapshot test in `tests/ui/`
5. Run `cargo insta review` to accept snapshots

#### Adding a Command

1. Add variant to `Command` enum in `src/commands/parser.rs`
2. Update `parse_command()` function
3. Add handler in `src/commands/handlers.rs`
4. Write tests (see existing examples)

### Testing

#### Running Tests

```bash
# Unit tests only (fast)
cargo test --lib

# Integration tests (requires Docker)
cargo test --test '*'

# Run ignored tests (for unimplemented features)
cargo test -- --ignored

# Run specific test
cargo test test_name
```

#### Writing Tests

Test structure:
```rust
#[test]
fn test_function_with_valid_input_returns_expected_output() {
    // Arrange
    let input = create_test_input();

    // Act
    let result = function_under_test(input);

    // Assert
    assert_eq!(result, expected);
}
```

For async tests:
```rust
#[tokio::test]
async fn test_async_operation() {
    let result = async_function().await;
    assert!(result.is_ok());
}
```

#### Using Test Helpers

Common test utilities in `tests/common/mod.rs`:
```rust
use vizgres_tests::common::test_schema;

let schema = test_schema(); // Standard test database schema
```

### Code Navigation

#### Key Files

- `src/lib.rs` - Library root, re-exports
- `src/main.rs` - Binary entry point
- `src/app.rs` - Application state machine
- `src/error.rs` - Error types
- `src/db/provider.rs` - Database trait
- `docs/` - Comprehensive design docs

#### Finding TODO Items

```bash
# Find all TODOs
rg "TODO:" --type rust

# Find Phase 1 TODOs
rg "TODO: Phase 1" --type rust

# Find unimplemented stubs
rg "todo!\(" --type rust
```

### Git Workflow

#### Commits

Write clear commit messages:
```
Implement PostgreSQL query execution

Add execute_query implementation for PostgresProvider:
- Convert tokio_postgres rows to QueryResults
- Map PostgreSQL types to our DataType enum
- Add proper error handling
- Include execution timing

Tests pass with testcontainers.
```

#### Branches

Feature branches should follow:
- `claude/<description>-<session-id>` (for Claude Code sessions)
- `feature/<description>`
- `fix/<description>`

### Common Patterns

#### Error Handling

```rust
// Use ? operator
let result = operation().map_err(|e|
    DbError::QueryFailed(format!("Operation failed: {}", e))
)?;

// Add context to errors
config.validate()
    .map_err(|e| ConfigError::Invalid(format!("Invalid config: {}", e)))?;
```

#### Async Operations

```rust
#[async_trait]
impl DatabaseProvider for PostgresProvider {
    async fn method(&self) -> Result<T> {
        // Async implementation
    }
}
```

#### Option/Result Handling

```rust
// Prefer combinators over match
let value = option
    .ok_or_else(|| Error::NotFound)?;

// Use if let for simple cases
if let Some(cached) = &self.cache {
    return Ok(cached.clone());
}
```

### Performance Considerations

#### Allocations

- Prefer `&str` over `String` in function parameters
- Use `Cow<str>` when sometimes owned, sometimes borrowed
- Clone only when necessary

#### Database Operations

- Cache schema to avoid repeated introspection
- Use prepared statements for repeated queries
- Batch operations when possible

#### UI Rendering

- Only render visible rows (virtual scrolling)
- Debounce rapid updates
- Cache layout calculations

### Getting Help

#### Documentation

1. Check `docs/` directory for design documentation
2. Read inline comments and doc comments
3. Look at existing implementations as examples

#### Asking Questions

When stuck:
1. State what you're trying to implement (phase + feature)
2. Show relevant code
3. Explain what you've tried
4. Include error messages if applicable

Example:
```
I'm implementing Phase 3 schema introspection in PostgresProvider.
The SQL query in get_schema() is returning empty results.

Current code: [paste relevant code]
Expected: Should return list of schemas/tables
Actual: Empty SchemaTree

I've checked that the connection works and can execute other queries.
```

### Best Practices Summary

✅ **DO**:
- Follow the phase-based roadmap
- Write tests for new code
- Run `cargo fmt` and `cargo clippy`
- Update documentation
- Use the existing error types
- Add helpful TODO comments
- Commit logically grouped changes

❌ **DON'T**:
- Skip ahead to later phases
- Commit code that doesn't compile
- Ignore clippy warnings
- Leave debugging code (println, etc.)
- Hardcode values that should be configurable
- Use `unwrap()` - prefer `?` or explicit error handling

## Project-Specific Notes

### Database Abstractions

The `DatabaseProvider` trait allows for multiple database backends. When implementing:
- Keep PostgreSQL-specific code in `src/db/postgres.rs`
- Use the trait for all app logic
- This makes testing easier (can use mocks)

### UI Components

Each widget implements the `Component` trait:
```rust
pub trait Component {
    fn handle_key(&mut self, key: KeyEvent) -> bool;
    fn render(&self, frame: &mut Frame, area: Rect, focused: bool);
    fn min_size(&self) -> (u16, u16);
}
```

### State Management

App state is centralized in `src/app.rs`:
- Events come in (`AppEvent`)
- State is updated
- Actions are returned (`Action`)
- UI renders based on state

## Quick Reference

### File Locations

| What | Where |
|------|-------|
| Add database method | `src/db/provider.rs` (trait), `src/db/postgres.rs` (impl) |
| Add UI widget | `src/ui/<widget>.rs` |
| Add command | `src/commands/parser.rs` |
| Add error type | `src/error.rs` |
| Integration test | `tests/integration/` |
| UI snapshot test | `tests/ui/` |
| Example config | `examples/config/` |

### Commands

```bash
# Development
cargo build
cargo run
cargo test

# Quality
cargo fmt
cargo clippy --all-targets -- -D warnings

# Coverage
cargo install cargo-llvm-cov
cargo llvm-cov --html
open target/llvm-cov/html/index.html

# Snapshot tests
cargo install cargo-insta
cargo insta test
cargo insta review
```

## Contributing

See `CONVENTIONS.md` for detailed coding standards.

---

**Questions?** Check the `docs/` directory or open an issue on GitHub.
